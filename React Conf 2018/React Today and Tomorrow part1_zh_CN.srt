1
00:00:00,350 --> 00:00:06,470
各位早上好。 Whoo! 早上好。

2
00:00:06,470 --> 00:00:11,400
欢迎来到 React Conf 2018。 我叫

3
00:00:11,400 --> 00:00:13,139
Tom Occhino。 我是 Facebook React 小组的

4
00:00:13,139 --> 00:00:15,420
技术总监。 真的非常

5
00:00:15,420 --> 00:00:16,560
激动来到这里。 我实际上真的

6
00:00:16,560 --> 00:00:18,750
非常激动能够和

7
00:00:18,750 --> 00:00:20,039
全国的人，乃至全世界的人

8
00:00:20,039 --> 00:00:22,529
对话。而且我知道

9
00:00:22,529 --> 00:00:23,670
还有在观看网络直播的各位, 我们拥有来自

10
00:00:23,670 --> 00:00:25,410
世界各地的观众。 非常感谢你们的

11
00:00:25,410 --> 00:00:27,180
到来。在开始之前，请允许我讲一些

12
00:00:27,180 --> 00:00:29,550
简单的后勤安排。 如果你

13
00:00:29,550 --> 00:00:30,960
还没有阅读大会的行为规范，

14
00:00:30,960 --> 00:00:33,600
请阅读一下。 行为准则发布在了登记处，

15
00:00:33,600 --> 00:00:36,390
和我们大会的网站上。请准守行为准则。 如果

16
00:00:36,390 --> 00:00:38,790
你有任何问题，请举手示意我

17
00:00:38,790 --> 00:00:40,680
或任何工作人员。 工作人员

18
00:00:40,680 --> 00:00:44,160
全部穿着紫色衬衫。 我们的演讲

19
00:00:44,160 --> 00:00:45,870
阵容非常强大。在这里今明

20
00:00:45,870 --> 00:00:49,680
两天会为你带来精彩的演讲。但如果你需要

21
00:00:49,680 --> 00:00:52,590
其他，呃， 如果你需要

22
00:00:52,590 --> 00:00:55,079
离开，如果你需要接打电话，请到

23
00:00:55,079 --> 00:00:56,579
我身后的

24
00:00:56,579 --> 00:00:58,649
房间。早餐厅

25
00:00:58,649 --> 00:01:01,680
已经开放了。在走廊里，可以看到

26
00:01:01,680 --> 00:01:03,570
Jen Lucas 的纤维艺术

27
00:01:03,570 --> 00:01:05,880
圆形针织物展览, 有时间

28
00:01:05,880 --> 00:01:07,710
可以去看看。如果你想离开。

29
00:01:07,710 --> 00:01:10,710
呃，今天会有

30
00:01:10,710 --> 00:01:12,390
更多的内容, 我们会在中午

31
00:01:12,390 --> 00:01:17,490
进行午餐。 在演讲开始

32
00:01:17,490 --> 00:01:20,340
之前, 我想

33
00:01:20,340 --> 00:01:23,030
对大会的组织者表示衷心的感谢。

34
00:01:23,030 --> 00:01:25,680
组织这场大会的工作量非常大。我们之前有点担心

35
00:01:25,680 --> 00:01:26,820
我们今年可能没有办法

36
00:01:26,820 --> 00:01:28,110
完成这项工作，因为

37
00:01:28,110 --> 00:01:30,270
工作量实在是太大了。 但是我们的大会

38
00:01:30,270 --> 00:01:33,270
组织者：React Rally, ng-conf

39
00:01:33,270 --> 00:01:37,710
Jamieson, Matt, Joe 还有 Zero

40
00:01:37,710 --> 00:01:39,530
Slope Events 帮助我们

41
00:01:39,530 --> 00:01:41,460
完成了今年大会的筹备。 我真的

42
00:01:41,460 --> 00:01:42,899
非常开心我们做到了。

43
00:01:42,899 --> 00:01:45,540
非常感谢你们的到来。 第一个

44
00:01:45,540 --> 00:01:47,640
演讲是我们的主题演讲，演讲者是 Sophie

45
00:01:47,640 --> 00:01:50,189
Alpert 和 Dan Abramov。 我们真的

46
00:01:50,189 --> 00:01:51,659
非常期待。 下面允许我有请

47
00:01:51,659 --> 00:01:54,090
Sophie 给我们带来开场演讲，

48
00:01:54,090 --> 00:01:57,050
谢谢。

49
00:01:57,050 --> 00:02:05,060
[掌声]

50
00:02:05,060 --> 00:02:12,120
早上好。大家好，

51
00:02:12,120 --> 00:02:14,670
欢迎来到 React 大会。今天来到这里我感到

52
00:02:14,670 --> 00:02:16,410
非常激动。我非常激动

53
00:02:16,410 --> 00:02:19,080
本周可以给你们

54
00:02:19,080 --> 00:02:22,310
做开场演讲。我是 Sophie Alpert，个人主页是

55
00:02:22,310 --> 00:02:24,720
sophiebits。

56
00:02:24,720 --> 00:02:26,870
我是 Facebook React 核心小组的经理。

57
00:02:26,870 --> 00:02:30,270
你们正在使用的 React 

58
00:02:30,270 --> 00:02:30,990
做的很好。

59
00:02:30,990 --> 00:02:32,850
我们在 npm 的下载量一年内增加了

60
00:02:32,850 --> 00:02:35,760
70 %。 React Dev Tools 在 Chrome 开发者工具

61
00:02:35,760 --> 00:02:37,890
扩展程序的安装量

62
00:02:37,890 --> 00:02:39,450
达到了 125 万。

63
00:02:39,450 --> 00:02:42,270
这是使用 React 的

64
00:02:42,270 --> 00:02:44,730
公司列表。此时此刻，

65
00:02:44,730 --> 00:02:46,140
这个列表已经非常长了，我们很难

66
00:02:46,140 --> 00:02:47,670
说清每年使用 React 的公司的变化。

67
00:02:47,670 --> 00:02:51,930
我们来看另一组数据，我们来看看

68
00:02:51,930 --> 00:02:53,970
Google 趋势, 它可以反映出网络搜索的

69
00:02:53,970 --> 00:02:56,010
流量。可以看到，React 的搜索量

70
00:02:56,010 --> 00:02:58,230
一直在增加。 希望这个数据表示

71
00:02:58,230 --> 00:02:59,970
有更多的人在使用 React，而不是

72
00:02:59,970 --> 00:03:04,170
React 变得更加令人困惑了。 [笑声] 嗯，为了

73
00:03:04,170 --> 00:03:06,630
做比较，我们比较了 jQuery 的

74
00:03:06,630 --> 00:03:10,200
搜索量，我们的搜索量刚刚在历史上首次

75
00:03:10,200 --> 00:03:15,820
超越了 jQuery。[欢呼和掌声] 

76
00:03:15,820 --> 00:03:19,160
但这也表明，我们仍然有很多

77
00:03:19,160 --> 00:03:21,740
成长的空间。呃，我在写这个演讲时

78
00:03:21,740 --> 00:03:24,290
被耽搁了一会儿。 因为我比较

79
00:03:24,290 --> 00:03:26,330
好奇 React 还比什么更

80
00:03:26,330 --> 00:03:29,770
流行。 哎呀。 [笑声]

81
00:03:29,770 --> 00:03:35,690
当我开了个玩笑。嗯，我发现 React

82
00:03:35,690 --> 00:03:37,580
比可再生能源

83
00:03:37,580 --> 00:03:40,820
更流行。 [笑声] React 也比

84
00:03:40,820 --> 00:03:43,400
橙汁更流行。 [笑声] 想想橙汁是多么

85
00:03:43,400 --> 00:03:45,350
常用啊，是吧。而且 React 比

86
00:03:45,350 --> 00:03:47,360
可再生能源和橙汁加在一起

87
00:03:47,360 --> 00:03:50,060
更流行。所以我认为

88
00:03:50,060 --> 00:03:53,180
我们有理由感到非常自豪。 但是

89
00:03:53,180 --> 00:03:56,480
除了这些数字，我今天真正想要讲的

90
00:03:56,480 --> 00:03:59,900
是 React 的

91
00:03:59,900 --> 00:04:02,240
使命。

92
00:04:02,240 --> 00:04:04,010
呃，自从 2013 年 React 发布以来，

93
00:04:04,010 --> 00:04:05,450
我们首要的目标、

94
00:04:05,450 --> 00:04:08,480
主要的使命就是：让开发者更容易地构建

95
00:04:08,480 --> 00:04:11,750
好的 UI。所以当我们

96
00:04:11,750 --> 00:04:14,120
想要增加新的特性时，我们通常都是

97
00:04:14,120 --> 00:04:15,620
要经过深思熟虑。当我们决定是否增加新的 API 时，

98
00:04:15,620 --> 00:04:16,970
我们需要考虑非常多的事情。

99
00:04:16,970 --> 00:04:19,520
如果增加新的 API 能够

100
00:04:19,520 --> 00:04:20,989
让你做到一些以前做不到的事情；

101
00:04:20,989 --> 00:04:23,480
如果可以显著简化

102
00:04:23,480 --> 00:04:25,940
组件里的代码

103
00:04:25,940 --> 00:04:27,470
和类库，让你的工作量

104
00:04:27,470 --> 00:04:29,540
减小，用户下载更少的代码，

105
00:04:29,540 --> 00:04:32,120
那新增 API 就是有价值的。或者如果新增 API 能够帮助

106
00:04:32,120 --> 00:04:33,950
我们做到代码分割的

107
00:04:33,950 --> 00:04:35,450
最佳实践，如果能够更容易地将你 app 里面的代码

108
00:04:35,450 --> 00:04:37,730
分割成多个包， 

109
00:04:37,730 --> 00:04:39,919
我们希望你的 app 最终可以

110
00:04:39,919 --> 00:04:41,720
运行更快。这也是我们两周之前

111
00:04:41,720 --> 00:04:43,430
宣布增加像 React.lazy 这样的

112
00:04:43,430 --> 00:04:44,870
API 的原因。 你们可能已经

113
00:04:44,870 --> 00:04:48,200
注意到了这个 API。 但想想 React 的使命，

114
00:04:48,200 --> 00:04:50,300
让开发者更容易地构建好的

115
00:04:50,300 --> 00:04:50,960
UI。

116
00:04:50,960 --> 00:04:52,640
我们有很多方法来

117
00:04:52,640 --> 00:04:55,730
实现这个目标。 其中一点是

118
00:04:55,730 --> 00:04:58,000
我们尝试简化复杂的东西。

119
00:04:58,000 --> 00:05:01,220
如果你看了 Dan Abramov 在冰岛的

120
00:05:01,220 --> 00:05:03,500
JS Conf 上的演讲，你可以抢先

121
00:05:03,500 --> 00:05:06,440
看到 "Suspense",  "Suspense" 是我们

122
00:05:06,440 --> 00:05:08,810
用来显著简化

123
00:05:08,810 --> 00:05:10,850
获取数据请求、代码分割

124
00:05:10,850 --> 00:05:13,940
和异步数据

125
00:05:13,940 --> 00:05:17,210
依赖的问题。 另外一个我们尝试

126
00:05:17,210 --> 00:05:19,730
去提升 React 的方式

127
00:05:19,730 --> 00:05:22,520
就是提升性能。如果你的 app 运行速度更快，

128
00:05:22,520 --> 00:05:24,530
你的用户就会更原意使用它。

129
00:05:24,530 --> 00:05:26,310
相反的，如果你的

130
00:05:26,310 --> 00:05:28,889
app 反映很慢，速度卡顿，那

131
00:05:28,889 --> 00:05:30,210
你的用户肯定不会有很好的

132
00:05:30,210 --> 00:05:32,880
体验。因此我们尝试让

133
00:05:32,880 --> 00:05:35,190
React 本身运行的更快，如果

134
00:05:35,190 --> 00:05:37,230
React 开箱就很快，那么你们

135
00:05:37,230 --> 00:05:38,880
就会省下很多优化你自己代码的时间。

136
00:05:38,880 --> 00:05:41,970
最近和提升性能有关的内容，

137
00:05:41,970 --> 00:05:43,830
Dan 也在冰岛的 JS Conf 上

138
00:05:43,830 --> 00:05:46,310
提到了，我们称其为 "Time Slicing"。

139
00:05:46,310 --> 00:05:49,470
"Time Slicing" 可以确保

140
00:05:49,470 --> 00:05:51,270
你 app 里面最重要的渲染

141
00:05:51,270 --> 00:05:53,340
会最先执行，解除主线程的

142
00:05:53,340 --> 00:05:55,080
阻塞，并且能让你的 app 运行地

143
00:05:55,080 --> 00:05:58,530
更快速。 第三种方式是

144
00:05:58,530 --> 00:06:00,419
使用开发者工具

145
00:06:00,419 --> 00:06:03,180
帮助你 debug ，进而更了解

146
00:06:03,180 --> 00:06:04,980
你的 app。一开始，

147
00:06:04,980 --> 00:06:07,050
React 就包含了对开发者友好的

148
00:06:07,050 --> 00:06:09,990
警告来帮助开发者指出问题，

149
00:06:09,990 --> 00:06:11,580
以防开发者没有注意到这些问题。

150
00:06:11,580 --> 00:06:13,200
而且我们的 React Dev Tools

151
00:06:13,200 --> 00:06:15,120
扩展程序能够让你检查并且

152
00:06:15,120 --> 00:06:17,580
debug 你的组件树。 在 React

153
00:06:17,580 --> 00:06:20,340
16.5 版本，我们引入了一个叫 Profiler 的新特性。它是

154
00:06:20,340 --> 00:06:24,660
第二个 ... （我不知道这个遥控器出了什么问题

155
00:06:24,660 --> 00:06:27,210
）... 图上的第二个标签栏就是 profiler 标签栏， 

156
00:06:27,210 --> 00:06:28,740
它能够帮助我们了解到

157
00:06:28,740 --> 00:06:32,690
你 app 中到底发生了什么，然后更好地优化它。所以

158
00:06:32,690 --> 00:06:35,580
Suspense, Time Slicing 和 Profiler

159
00:06:35,580 --> 00:06:37,770
这三个新特性是我们

160
00:06:37,770 --> 00:06:39,990
去年一直在做的事情。 我们

161
00:06:39,990 --> 00:06:41,250
真的想多说一些关于这三个特性的

162
00:06:41,250 --> 00:06:43,169
内容。但是这些并不是我今天在这里想要

163
00:06:43,169 --> 00:06:44,729
讲的。大家可以等到明天，

164
00:06:44,729 --> 00:06:46,169
Andrew 和 Brian 会在明天早上

165
00:06:46,169 --> 00:06:47,729
给大家带来关于这个内容的演讲。

166
00:06:47,729 --> 00:06:50,850
现在我想退一步，

167
00:06:50,850 --> 00:06:52,080
我们来关注一些其他的问题。

168
00:06:52,080 --> 00:06:55,470
我想问的是，现在 React 还有什么

169
00:06:55,470 --> 00:06:58,560
糟糕的地方。我总结出了三个问题，

170
00:06:58,560 --> 00:07:01,410
在这里想和大家来讨论。

171
00:07:01,410 --> 00:07:03,990
第一个问题就是多组件间的逻辑复用

172
00:07:03,990 --> 00:07:07,320
问题。在 React 中我们主要使用

173
00:07:07,320 --> 00:07:09,030
组件来构建我们的应用，

174
00:07:09,030 --> 00:07:10,710
组件主要有

175
00:07:10,710 --> 00:07:13,350
两种主要的模式

176
00:07:13,350 --> 00:07:15,030
来复用代码：

177
00:07:15,030 --> 00:07:16,500
它们是高阶组件（higher-order）

178
00:07:16,500 --> 00:07:19,560
和渲染属性（render props)。这两种

179
00:07:19,560 --> 00:07:21,120
模式对于某些场景来说是很好的，

180
00:07:21,120 --> 00:07:22,979
但是它们也造成了一个极大的

181
00:07:22,979 --> 00:07:25,380
缺点。在更加复杂的场景中，

182
00:07:25,380 --> 00:07:26,970
你必须将他们抽离出来去

183
00:07:26,970 --> 00:07:29,250
重构你的 app。

184
00:07:29,250 --> 00:07:31,610
这会导致一个问题，我称之为”包装地狱“（wrapper hell）。

185
00:07:31,610 --> 00:07:33,930
嗯，我们经常会看到

186
00:07:33,930 --> 00:07:37,479
像这样的组件树。 [尖叫和笑声]

187
00:07:37,479 --> 00:07:41,749
而且这种嵌套会造成

188
00:07:41,749 --> 00:07:43,519
跟踪 app 数据流的困难。

189
00:07:43,519 --> 00:07:45,259
如果

190
00:07:45,259 --> 00:07:47,239
能够复用这类

191
00:07:47,239 --> 00:07:48,949
有状态的逻辑，而不需要

192
00:07:48,949 --> 00:07:51,759
修改组件的层级，那肯定是很好的方法，对吧。

193
00:07:51,759 --> 00:07:53,899
第二个我像讲的问题是

194
00:07:53,899 --> 00:07:57,080
庞大的组件，它的逻辑

195
00:07:57,080 --> 00:07:59,179
杂乱无章。 我们来看看一个

196
00:07:59,179 --> 00:08:00,739
上千行代码的 React 组件，

197
00:08:00,739 --> 00:08:03,379
我们会发现逻辑

198
00:08:03,379 --> 00:08:04,369
分散到了许多不同的

199
00:08:04,369 --> 00:08:06,080
生命周期函数中，这样

200
00:08:06,080 --> 00:08:08,239
非常难以跟踪。我们来看一个

201
00:08:08,239 --> 00:08:10,459
例子。这里有一个 class

202
00:08:10,459 --> 00:08:12,589
组件，在它的 did mount

203
00:08:12,589 --> 00:08:14,119
方法，它做了几件事：它

204
00:08:14,119 --> 00:08:15,919
订阅了一个数据存储中，然后发送了一个

205
00:08:15,919 --> 00:08:17,739
网络请求，最后开启了一个定时器。

206
00:08:17,739 --> 00:08:20,989
那么，如果我们来看组件的 will

207
00:08:20,989 --> 00:08:23,029
unmount 方法，我们会看到

208
00:08:23,029 --> 00:08:24,679
基本完全相反的

209
00:08:24,679 --> 00:08:26,179
代码：首先需要取消存储的订阅，

210
00:08:26,179 --> 00:08:28,189
然后取消网络请求，

211
00:08:28,189 --> 00:08:29,869
最后停止定时器。

212
00:08:29,869 --> 00:08:31,879
当我们要实现

213
00:08:31,879 --> 00:08:34,039
组件的 did update 方法, 里面的逻辑会

214
00:08:34,039 --> 00:08:35,329
更加的 tricky。因为你需要

215
00:08:35,329 --> 00:08:38,089
比较新旧的属性

216
00:08:38,089 --> 00:08:41,360
然后再一次重复和其他生命周期函数内部

217
00:08:41,360 --> 00:08:43,099
相同的任务逻辑。

218
00:08:43,099 --> 00:08:49,189
呃，在这个例子里，每个请求都是

219
00:08:49,189 --> 00:08:50,720
只有一行，所以说这个例子实际上比

220
00:08:50,720 --> 00:08:52,100
你平时看到的组件要

221
00:08:52,100 --> 00:08:53,990
简单的多。在真实组件中，

222
00:08:53,990 --> 00:08:55,730
逻辑往往会更加错综复杂，

223
00:08:55,730 --> 00:08:58,100
因为每个

224
00:08:58,100 --> 00:08:59,899
独立的任务分散到了

225
00:08:59,899 --> 00:09:02,240
不同的生命周期函数中，这样

226
00:09:02,240 --> 00:09:04,279
会造成困难，举个例子，当你 unmounting 组件时，

227
00:09:04,279 --> 00:09:06,170
你可能会

228
00:09:06,170 --> 00:09:07,639
忘记清除资源。

229
00:09:07,639 --> 00:09:08,810
这非常难以从代码中找到

230
00:09:08,810 --> 00:09:13,540
问题。 第三个糟糕的事情是

231
00:09:13,540 --> 00:09:17,180
class。理解 JavaScript 里的 classes

232
00:09:17,180 --> 00:09:18,620
会相当 tricky，而且现在

233
00:09:18,620 --> 00:09:22,220
我们要求你们使用 class 组件，

234
00:09:22,220 --> 00:09:24,680
为了能够使用 state 和

235
00:09:24,680 --> 00:09:27,019
生命周期。如果你用过

236
00:09:27,019 --> 00:09:28,880
function 组件，而且将其转为了

237
00:09:28,880 --> 00:09:30,800
class 组件，增加了一些 state，你就会知道

238
00:09:30,800 --> 00:09:31,910
需要有大量的样本文件

239
00:09:31,910 --> 00:09:35,089
作用仅仅是用来定义一个

240
00:09:35,089 --> 00:09:37,850
class 组件。大多数初学者和

241
00:09:37,850 --> 00:09:40,660
很多有经验的开发者也都跟我们抱怨过

242
00:09:40,660 --> 00:09:43,819
在 class 里面的绑定和转化工作

243
00:09:43,819 --> 00:09:46,160
相当令人困惑。 我们有必要来

244
00:09:46,160 --> 00:09:48,050
考虑这个问题。而且我们经常听说

245
00:09:48,050 --> 00:09:49,550
大家并不是

246
00:09:49,550 --> 00:09:50,089
非常清楚

247
00:09:50,089 --> 00:09:51,589
什么时候使用 function 组件，

248
00:09:51,589 --> 00:09:52,970
一部分原因是他们总会担心

249
00:09:52,970 --> 00:09:54,740
早晚需要将这个组件转化为

250
00:09:54,740 --> 00:09:56,870
class 组件。所以你们可能会困惑，

251
00:09:56,870 --> 00:10:00,079
我现在是否应该这么做？我不知道。

252
00:10:00,079 --> 00:10:02,870
所以我说 classes 对于人类来说

253
00:10:02,870 --> 00:10:07,309
是很难的，但是不是对于人类而言是这样，我也断言

254
00:10:07,309 --> 00:10:09,819
classes 对于机器而言也是很难的。

255
00:10:09,819 --> 00:10:11,899
如果你看过压缩后的

256
00:10:11,899 --> 00:10:13,550
组件文件，可以看到所有的

257
00:10:13,550 --> 00:10:16,699
方法名没有被压缩。而且如果

258
00:10:16,699 --> 00:10:18,170
你有一个完全没有使用的方法，

259
00:10:18,170 --> 00:10:19,759
它也没有被剔除出去。

260
00:10:19,759 --> 00:10:21,709
这是因为在编译时

261
00:10:21,709 --> 00:10:22,339
很难准确判断

262
00:10:22,339 --> 00:10:25,029
方法是否被使用。

263
00:10:25,029 --> 00:10:27,620
我们还发现 classes 使得

264
00:10:27,620 --> 00:10:29,269
可靠的热加载变得困难。

265
00:10:29,269 --> 00:10:32,899
最后当我们

266
00:10:32,899 --> 00:10:34,730
设计一个优化的编译器原型来

267
00:10:34,730 --> 00:10:36,800
提升 React 组件性能时，

268
00:10:36,800 --> 00:10:39,319
我们发现 class 组件

269
00:10:39,319 --> 00:10:41,329
的一些模式使得

270
00:10:41,329 --> 00:10:46,009
编译器优化变得更难。所以，

271
00:10:46,009 --> 00:10:47,420
我们现在有三个问题：

272
00:10:47,420 --> 00:10:52,300
逻辑复用、庞大的组件和

273
00:10:52,300 --> 00:10:55,399
classes。逻辑复用的问题会导致你

274
00:10:55,399 --> 00:10:56,769
经常遇到“包装地狱“。

275
00:10:56,769 --> 00:10:59,240
庞大组件的原因是由于

276
00:10:59,240 --> 00:11:01,129
逻辑分散到了不同的生命周期中。

277
00:11:01,129 --> 00:11:04,220
而令人困惑的 classes 无论对于人类还是机器来说

278
00:11:04,220 --> 00:11:07,459
都是个难题。 我们认为我们有了一个

279
00:11:07,459 --> 00:11:09,529
能够解决以上三个问题的解决方案。

280
00:11:09,529 --> 00:11:11,449
我们特别像把这个方案分享给大家。

281
00:11:11,449 --> 00:11:13,639
请允许我请出

282
00:11:13,639 --> 00:11:16,290
Dan Abramov 为我们带来接下来的演讲。

283
00:11:16,290 --> 00:11:26,080
[掌声]

284
00:11:26,080 --> 00:11:27,820
[掌声]